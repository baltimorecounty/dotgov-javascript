var BcModal =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/components/Modal.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/a11y-dialog/a11y-dialog.js":
/*!*************************************************!*\
  !*** ./node_modules/a11y-dialog/a11y-dialog.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/* global NodeList, Element, Event, define */\n(function (global) {\n  'use strict';\n\n  var FOCUSABLE_ELEMENTS = ['a[href]:not([tabindex^=\"-\"]):not([inert])', 'area[href]:not([tabindex^=\"-\"]):not([inert])', 'input:not([disabled]):not([inert])', 'select:not([disabled]):not([inert])', 'textarea:not([disabled]):not([inert])', 'button:not([disabled]):not([inert])', 'iframe:not([tabindex^=\"-\"]):not([inert])', 'audio:not([tabindex^=\"-\"]):not([inert])', 'video:not([tabindex^=\"-\"]):not([inert])', '[contenteditable]:not([tabindex^=\"-\"]):not([inert])', '[tabindex]:not([tabindex^=\"-\"]):not([inert])'];\n  var TAB_KEY = 9;\n  var ESCAPE_KEY = 27;\n  var focusedBeforeDialog;\n  /**\n   * Define the constructor to instantiate a dialog\n   *\n   * @constructor\n   * @param {Element} node\n   * @param {(NodeList | Element | string)} targets\n   */\n\n  function A11yDialog(node, targets) {\n    // Prebind the functions that will be bound in addEventListener and\n    // removeEventListener to avoid losing references\n    this._show = this.show.bind(this);\n    this._hide = this.hide.bind(this);\n    this._maintainFocus = this._maintainFocus.bind(this);\n    this._bindKeypress = this._bindKeypress.bind(this); // Keep a reference of the node and the actual dialog on the instance\n\n    this.container = node;\n    this.dialog = node.querySelector('dialog, [role=\"dialog\"], [role=\"alertdialog\"]');\n    this.role = this.dialog.getAttribute('role') || 'dialog';\n    this.useDialog = 'show' in document.createElement('dialog') && this.dialog.nodeName === 'DIALOG'; // Keep an object of listener types mapped to callback functions\n\n    this._listeners = {}; // Initialise everything needed for the dialog to work properly\n\n    this.create(targets);\n  }\n  /**\n   * Set up everything necessary for the dialog to be functioning\n   *\n   * @param {(NodeList | Element | string)} targets\n   * @return {this}\n   */\n\n\n  A11yDialog.prototype.create = function (targets) {\n    // Keep a collection of nodes to disable/enable when toggling the dialog\n    this._targets = this._targets || collect(targets) || getSiblings(this.container); // Set the `shown` property to match the status from the DOM\n\n    this.shown = this.dialog.hasAttribute('open'); // Despite using a `<dialog>` element, `role=\"dialog\"` is not necessarily\n    // implied by all screen-readers (yet)\n    // See: https://github.com/edenspiekermann/a11y-dialog/commit/6ba711a777aed0dbda0719a18a02f742098c64d9#commitcomment-28694166\n\n    this.dialog.setAttribute('role', this.role);\n\n    if (!this.useDialog) {\n      if (this.shown) {\n        this.container.removeAttribute('aria-hidden');\n      } else {\n        this.container.setAttribute('aria-hidden', true);\n      }\n    } else {\n      this.container.setAttribute('data-a11y-dialog-native', '');\n    } // Keep a collection of dialog openers, each of which will be bound a click\n    // event listener to open the dialog\n\n\n    this._openers = $$('[data-a11y-dialog-show=\"' + this.container.id + '\"]');\n\n    this._openers.forEach(function (opener) {\n      opener.addEventListener('click', this._show);\n    }.bind(this)); // Keep a collection of dialog closers, each of which will be bound a click\n    // event listener to close the dialog\n\n\n    this._closers = $$('[data-a11y-dialog-hide]', this.container).concat($$('[data-a11y-dialog-hide=\"' + this.container.id + '\"]'));\n\n    this._closers.forEach(function (closer) {\n      closer.addEventListener('click', this._hide);\n    }.bind(this)); // Execute all callbacks registered for the `create` event\n\n\n    this._fire('create');\n\n    return this;\n  };\n  /**\n   * Show the dialog element, disable all the targets (siblings), trap the\n   * current focus within it, listen for some specific key presses and fire all\n   * registered callbacks for `show` event\n   *\n   * @param {Event} event\n   * @return {this}\n   */\n\n\n  A11yDialog.prototype.show = function (event) {\n    // If the dialog is already open, abort\n    if (this.shown) {\n      return this;\n    }\n\n    this.shown = true; // Keep a reference to the currently focused element to be able to restore\n    // it later\n\n    focusedBeforeDialog = document.activeElement;\n\n    if (this.useDialog) {\n      this.dialog.showModal(event instanceof Event ? void 0 : event);\n    } else {\n      this.dialog.setAttribute('open', '');\n      this.container.removeAttribute('aria-hidden'); // Iterate over the targets to disable them by setting their `aria-hidden`\n      // attribute to `true`\n\n      this._targets.forEach(function (target) {\n        target.setAttribute('aria-hidden', 'true');\n      });\n    } // Set the focus to the first focusable child of the dialog element\n\n\n    setFocusToFirstItem(this.dialog); // Bind a focus event listener to the body element to make sure the focus\n    // stays trapped inside the dialog while open, and start listening for some\n    // specific key presses (TAB and ESC)\n\n    document.body.addEventListener('focus', this._maintainFocus, true);\n    document.addEventListener('keydown', this._bindKeypress); // Execute all callbacks registered for the `show` event\n\n    this._fire('show', event);\n\n    return this;\n  };\n  /**\n   * Hide the dialog element, enable all the targets (siblings), restore the\n   * focus to the previously active element, stop listening for some specific\n   * key presses and fire all registered callbacks for `hide` event\n   *\n   * @param {Event} event\n   * @return {this}\n   */\n\n\n  A11yDialog.prototype.hide = function (event) {\n    // If the dialog is already closed, abort\n    if (!this.shown) {\n      return this;\n    }\n\n    this.shown = false;\n\n    if (this.useDialog) {\n      this.dialog.close(event instanceof Event ? void 0 : event);\n    } else {\n      this.dialog.removeAttribute('open');\n      this.container.setAttribute('aria-hidden', 'true'); // Iterate over the targets to enable them by remove their `aria-hidden`\n      // attribute\n\n      this._targets.forEach(function (target) {\n        target.removeAttribute('aria-hidden');\n      });\n    } // If their was a focused element before the dialog was opened, restore the\n    // focus back to it\n\n\n    if (focusedBeforeDialog) {\n      focusedBeforeDialog.focus();\n    } // Remove the focus event listener to the body element and stop listening\n    // for specific key presses\n\n\n    document.body.removeEventListener('focus', this._maintainFocus, true);\n    document.removeEventListener('keydown', this._bindKeypress); // Execute all callbacks registered for the `hide` event\n\n    this._fire('hide', event);\n\n    return this;\n  };\n  /**\n   * Destroy the current instance (after making sure the dialog has been hidden)\n   * and remove all associated listeners from dialog openers and closers\n   *\n   * @return {this}\n   */\n\n\n  A11yDialog.prototype.destroy = function () {\n    // Hide the dialog to avoid destroying an open instance\n    this.hide(); // Remove the click event listener from all dialog openers\n\n    this._openers.forEach(function (opener) {\n      opener.removeEventListener('click', this._show);\n    }.bind(this)); // Remove the click event listener from all dialog closers\n\n\n    this._closers.forEach(function (closer) {\n      closer.removeEventListener('click', this._hide);\n    }.bind(this)); // Execute all callbacks registered for the `destroy` event\n\n\n    this._fire('destroy'); // Keep an object of listener types mapped to callback functions\n\n\n    this._listeners = {};\n    return this;\n  };\n  /**\n   * Register a new callback for the given event type\n   *\n   * @param {string} type\n   * @param {Function} handler\n   */\n\n\n  A11yDialog.prototype.on = function (type, handler) {\n    if (typeof this._listeners[type] === 'undefined') {\n      this._listeners[type] = [];\n    }\n\n    this._listeners[type].push(handler);\n\n    return this;\n  };\n  /**\n   * Unregister an existing callback for the given event type\n   *\n   * @param {string} type\n   * @param {Function} handler\n   */\n\n\n  A11yDialog.prototype.off = function (type, handler) {\n    var index = this._listeners[type].indexOf(handler);\n\n    if (index > -1) {\n      this._listeners[type].splice(index, 1);\n    }\n\n    return this;\n  };\n  /**\n   * Iterate over all registered handlers for given type and call them all with\n   * the dialog element as first argument, event as second argument (if any).\n   *\n   * @access private\n   * @param {string} type\n   * @param {Event} event\n   */\n\n\n  A11yDialog.prototype._fire = function (type, event) {\n    var listeners = this._listeners[type] || [];\n    listeners.forEach(function (listener) {\n      listener(this.container, event);\n    }.bind(this));\n  };\n  /**\n   * Private event handler used when listening to some specific key presses\n   * (namely ESCAPE and TAB)\n   *\n   * @access private\n   * @param {Event} event\n   */\n\n\n  A11yDialog.prototype._bindKeypress = function (event) {\n    // If the dialog is shown and the ESCAPE key is being pressed, prevent any\n    // further effects from the ESCAPE key and hide the dialog, unless its role\n    // is 'alertdialog', which should be modal\n    if (this.shown && event.which === ESCAPE_KEY && this.role !== 'alertdialog') {\n      event.preventDefault();\n      this.hide();\n    } // If the dialog is shown and the TAB key is being pressed, make sure the\n    // focus stays trapped within the dialog element\n\n\n    if (this.shown && event.which === TAB_KEY) {\n      trapTabKey(this.dialog, event);\n    }\n  };\n  /**\n   * Private event handler used when making sure the focus stays within the\n   * currently open dialog\n   *\n   * @access private\n   * @param {Event} event\n   */\n\n\n  A11yDialog.prototype._maintainFocus = function (event) {\n    // If the dialog is shown and the focus is not within the dialog element,\n    // move it back to its first focusable child\n    if (this.shown && !this.container.contains(event.target)) {\n      setFocusToFirstItem(this.dialog);\n    }\n  };\n  /**\n   * Convert a NodeList into an array\n   *\n   * @param {NodeList} collection\n   * @return {Array<Element>}\n   */\n\n\n  function toArray(collection) {\n    return Array.prototype.slice.call(collection);\n  }\n  /**\n   * Query the DOM for nodes matching the given selector, scoped to context (or\n   * the whole document)\n   *\n   * @param {String} selector\n   * @param {Element} [context = document]\n   * @return {Array<Element>}\n   */\n\n\n  function $$(selector, context) {\n    return toArray((context || document).querySelectorAll(selector));\n  }\n  /**\n   * Return an array of Element based on given argument (NodeList, Element or\n   * string representing a selector)\n   *\n   * @param {(NodeList | Element | string)} target\n   * @return {Array<Element>}\n   */\n\n\n  function collect(target) {\n    if (NodeList.prototype.isPrototypeOf(target)) {\n      return toArray(target);\n    }\n\n    if (Element.prototype.isPrototypeOf(target)) {\n      return [target];\n    }\n\n    if (typeof target === 'string') {\n      return $$(target);\n    }\n  }\n  /**\n   * Set the focus to the first element with `autofocus` or the first focusable\n   * child of the given element\n   *\n   * @param {Element} node\n   */\n\n\n  function setFocusToFirstItem(node) {\n    var focusableChildren = getFocusableChildren(node);\n    var focused = node.querySelector('[autofocus]') || focusableChildren[0];\n\n    if (focused) {\n      focused.focus();\n    }\n  }\n  /**\n   * Get the focusable children of the given element\n   *\n   * @param {Element} node\n   * @return {Array<Element>}\n   */\n\n\n  function getFocusableChildren(node) {\n    return $$(FOCUSABLE_ELEMENTS.join(','), node).filter(function (child) {\n      return !!(child.offsetWidth || child.offsetHeight || child.getClientRects().length);\n    });\n  }\n  /**\n   * Trap the focus inside the given element\n   *\n   * @param {Element} node\n   * @param {Event} event\n   */\n\n\n  function trapTabKey(node, event) {\n    var focusableChildren = getFocusableChildren(node);\n    var focusedItemIndex = focusableChildren.indexOf(document.activeElement); // If the SHIFT key is being pressed while tabbing (moving backwards) and\n    // the currently focused item is the first one, move the focus to the last\n    // focusable item from the dialog element\n\n    if (event.shiftKey && focusedItemIndex === 0) {\n      focusableChildren[focusableChildren.length - 1].focus();\n      event.preventDefault(); // If the SHIFT key is not being pressed (moving forwards) and the currently\n      // focused item is the last one, move the focus to the first focusable item\n      // from the dialog element\n    } else if (!event.shiftKey && focusedItemIndex === focusableChildren.length - 1) {\n      focusableChildren[0].focus();\n      event.preventDefault();\n    }\n  }\n  /**\n   * Retrieve siblings from given element\n   *\n   * @param {Element} node\n   * @return {Array<Element>}\n   */\n\n\n  function getSiblings(node) {\n    var nodes = toArray(node.parentNode.childNodes);\n    var siblings = nodes.filter(function (node) {\n      return node.nodeType === 1;\n    });\n    siblings.splice(siblings.indexOf(node), 1);\n    return siblings;\n  }\n\n  if ( true && typeof module.exports !== 'undefined') {\n    module.exports = A11yDialog;\n  } else if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return A11yDialog;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(typeof global !== 'undefined' ? global : window);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://Bc%5Bname%5D/./node_modules/a11y-dialog/a11y-dialog.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function(\"return this\")();\n} catch (e) {\n  // This works if the window reference is available\n  if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;\n\n//# sourceURL=webpack://Bc%5Bname%5D/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/components/Modal.js":
/*!*********************************!*\
  !*** ./src/components/Modal.js ***!
  \*********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var a11y_dialog__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! a11y-dialog */ \"./node_modules/a11y-dialog/a11y-dialog.js\");\n/* harmony import */ var a11y_dialog__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(a11y_dialog__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar initializeModal = function initializeModal(modalElm) {\n  var dialog = modalElm;\n  new a11y_dialog__WEBPACK_IMPORTED_MODULE_0___default.a(dialog);\n};\n\ndocument.addEventListener(\"DOMContentLoaded\", function (onContentLoadedEvent) {\n  var modalClass = \"dg_modal\";\n  var modalElms = document.querySelectorAll(\"[class*=\".concat(modalClass, \"]\"));\n  modalElms.forEach(initializeModal);\n});\n\n//# sourceURL=webpack://Bc%5Bname%5D/./src/components/Modal.js?");

/***/ })

/******/ });