var BcSiteNavigation =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/site/SiteNavigation.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/focus-trap/index.js":
/*!******************************************!*\
  !*** ./node_modules/focus-trap/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var tabbable = __webpack_require__(/*! tabbable */ \"./node_modules/tabbable/index.js\");\nvar xtend = __webpack_require__(/*! xtend */ \"./node_modules/xtend/immutable.js\");\n\nvar activeFocusDelay;\n\nvar activeFocusTraps = (function() {\n  var trapQueue = [];\n  return {\n    activateTrap: function(trap) {\n      if (trapQueue.length > 0) {\n        var activeTrap = trapQueue[trapQueue.length - 1];\n        if (activeTrap !== trap) {\n          activeTrap.pause();\n        }\n      }\n\n      var trapIndex = trapQueue.indexOf(trap);\n      if (trapIndex === -1) {\n        trapQueue.push(trap);\n      } else {\n        // move this existing trap to the front of the queue\n        trapQueue.splice(trapIndex, 1);\n        trapQueue.push(trap);\n      }\n    },\n\n    deactivateTrap: function(trap) {\n      var trapIndex = trapQueue.indexOf(trap);\n      if (trapIndex !== -1) {\n        trapQueue.splice(trapIndex, 1);\n      }\n\n      if (trapQueue.length > 0) {\n        trapQueue[trapQueue.length - 1].unpause();\n      }\n    }\n  };\n})();\n\nfunction focusTrap(element, userOptions) {\n  var doc = document;\n  var container =\n    typeof element === 'string' ? doc.querySelector(element) : element;\n\n  var config = xtend(\n    {\n      returnFocusOnDeactivate: true,\n      escapeDeactivates: true\n    },\n    userOptions\n  );\n\n  var state = {\n    firstTabbableNode: null,\n    lastTabbableNode: null,\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false\n  };\n\n  var trap = {\n    activate: activate,\n    deactivate: deactivate,\n    pause: pause,\n    unpause: unpause\n  };\n\n  return trap;\n\n  function activate(activateOptions) {\n    if (state.active) return;\n\n    updateTabbableNodes();\n\n    state.active = true;\n    state.paused = false;\n    state.nodeFocusedBeforeActivation = doc.activeElement;\n\n    var onActivate =\n      activateOptions && activateOptions.onActivate\n        ? activateOptions.onActivate\n        : config.onActivate;\n    if (onActivate) {\n      onActivate();\n    }\n\n    addListeners();\n    return trap;\n  }\n\n  function deactivate(deactivateOptions) {\n    if (!state.active) return;\n\n    clearTimeout(activeFocusDelay);\n\n    removeListeners();\n    state.active = false;\n    state.paused = false;\n\n    activeFocusTraps.deactivateTrap(trap);\n\n    var onDeactivate =\n      deactivateOptions && deactivateOptions.onDeactivate !== undefined\n        ? deactivateOptions.onDeactivate\n        : config.onDeactivate;\n    if (onDeactivate) {\n      onDeactivate();\n    }\n\n    var returnFocus =\n      deactivateOptions && deactivateOptions.returnFocus !== undefined\n        ? deactivateOptions.returnFocus\n        : config.returnFocusOnDeactivate;\n    if (returnFocus) {\n      delay(function() {\n        tryFocus(state.nodeFocusedBeforeActivation);\n      });\n    }\n\n    return trap;\n  }\n\n  function pause() {\n    if (state.paused || !state.active) return;\n    state.paused = true;\n    removeListeners();\n  }\n\n  function unpause() {\n    if (!state.paused || !state.active) return;\n    state.paused = false;\n    updateTabbableNodes();\n    addListeners();\n  }\n\n  function addListeners() {\n    if (!state.active) return;\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    activeFocusDelay = delay(function() {\n      tryFocus(getInitialFocusNode());\n    });\n\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n\n    return trap;\n  }\n\n  function removeListeners() {\n    if (!state.active) return;\n\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n\n    return trap;\n  }\n\n  function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n    var node = optionValue;\n    if (!optionValue) {\n      return null;\n    }\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue);\n      if (!node) {\n        throw new Error('`' + optionName + '` refers to no known node');\n      }\n    }\n    if (typeof optionValue === 'function') {\n      node = optionValue();\n      if (!node) {\n        throw new Error('`' + optionName + '` did not return a node');\n      }\n    }\n    return node;\n  }\n\n  function getInitialFocusNode() {\n    var node;\n    if (getNodeForOption('initialFocus') !== null) {\n      node = getNodeForOption('initialFocus');\n    } else if (container.contains(doc.activeElement)) {\n      node = doc.activeElement;\n    } else {\n      node = state.firstTabbableNode || getNodeForOption('fallbackFocus');\n    }\n\n    if (!node) {\n      throw new Error(\n        \"You can't have a focus-trap without at least one focusable element\"\n      );\n    }\n\n    return node;\n  }\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  function checkPointerDown(e) {\n    if (container.contains(e.target)) return;\n    if (config.clickOutsideDeactivates) {\n      deactivate({\n        returnFocus: !tabbable.isFocusable(e.target)\n      });\n      return;\n    }\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (config.allowOutsideClick && config.allowOutsideClick(e)) {\n      return;\n    }\n    e.preventDefault();\n  }\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  function checkFocusIn(e) {\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (container.contains(e.target) || e.target instanceof Document) {\n      return;\n    }\n    e.stopImmediatePropagation();\n    tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n  }\n\n  function checkKey(e) {\n    if (config.escapeDeactivates !== false && isEscapeEvent(e)) {\n      e.preventDefault();\n      deactivate();\n      return;\n    }\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  }\n\n  // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  function checkTab(e) {\n    updateTabbableNodes();\n    if (e.shiftKey && e.target === state.firstTabbableNode) {\n      e.preventDefault();\n      tryFocus(state.lastTabbableNode);\n      return;\n    }\n    if (!e.shiftKey && e.target === state.lastTabbableNode) {\n      e.preventDefault();\n      tryFocus(state.firstTabbableNode);\n      return;\n    }\n  }\n\n  function checkClick(e) {\n    if (config.clickOutsideDeactivates) return;\n    if (container.contains(e.target)) return;\n    if (config.allowOutsideClick && config.allowOutsideClick(e)) {\n      return;\n    }\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  }\n\n  function updateTabbableNodes() {\n    var tabbableNodes = tabbable(container);\n    state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();\n    state.lastTabbableNode =\n      tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();\n  }\n\n  function tryFocus(node) {\n    if (node === doc.activeElement) return;\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n\n    node.focus();\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  }\n}\n\nfunction isSelectableInput(node) {\n  return (\n    node.tagName &&\n    node.tagName.toLowerCase() === 'input' &&\n    typeof node.select === 'function'\n  );\n}\n\nfunction isEscapeEvent(e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n}\n\nfunction isTabEvent(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n}\n\nfunction delay(fn) {\n  return setTimeout(fn, 0);\n}\n\nmodule.exports = focusTrap;\n\n\n//# sourceURL=webpack://Bc%5Bname%5D/./node_modules/focus-trap/index.js?");

/***/ }),

/***/ "./node_modules/tabbable/index.js":
/*!****************************************!*\
  !*** ./node_modules/tabbable/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n];\nvar candidateSelector = candidateSelectors.join(',');\n\nvar matches = typeof Element === 'undefined'\n  ? function () {}\n  : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n\n  var regularTabbables = [];\n  var orderedTabbables = [];\n\n  var candidates = el.querySelectorAll(candidateSelector);\n\n  if (options.includeContainer) {\n    if (matches.call(el, candidateSelector)) {\n      candidates = Array.prototype.slice.apply(candidates);\n      candidates.unshift(el);\n    }\n  }\n\n  var i, candidate, candidateTabindex;\n  for (i = 0; i < candidates.length; i++) {\n    candidate = candidates[i];\n\n    if (!isNodeMatchingSelectorTabbable(candidate)) continue;\n\n    candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  }\n\n  var tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map(function(a) { return a.node })\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n}\n\ntabbable.isTabbable = isTabbable;\ntabbable.isFocusable = isFocusable;\n\nfunction isNodeMatchingSelectorTabbable(node) {\n  if (\n    !isNodeMatchingSelectorFocusable(node)\n    || isNonTabbableRadio(node)\n    || getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isTabbable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, candidateSelector) === false) return false;\n  return isNodeMatchingSelectorTabbable(node);\n}\n\nfunction isNodeMatchingSelectorFocusable(node) {\n  if (\n    node.disabled\n    || isHiddenInput(node)\n    || isHidden(node)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nvar focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');\nfunction isFocusable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, focusableCandidateSelector) === false) return false;\n  return isNodeMatchingSelectorFocusable(node);\n}\n\nfunction getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n  if (!isNaN(tabindexAttr)) return tabindexAttr;\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) return 0;\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) return true;\n  // This won't account for the edge case where you have radio groups with the same\n  // in separate forms on the same page.\n  var radioSet = node.ownerDocument.querySelectorAll('input[type=\"radio\"][name=\"' + node.name + '\"]');\n  var checked = getCheckedRadio(radioSet);\n  return !checked || checked === node;\n}\n\nfunction isHidden(node) {\n  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,\n  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.\n  return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';\n}\n\nmodule.exports = tabbable;\n\n\n//# sourceURL=webpack://Bc%5Bname%5D/./node_modules/tabbable/index.js?");

/***/ }),

/***/ "./node_modules/xtend/immutable.js":
/*!*****************************************!*\
  !*** ./node_modules/xtend/immutable.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n\n\n//# sourceURL=webpack://Bc%5Bname%5D/./node_modules/xtend/immutable.js?");

/***/ }),

/***/ "./src/site/SiteNavigation.js":
/*!************************************!*\
  !*** ./src/site/SiteNavigation.js ***!
  \************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
<<<<<<< HEAD
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utilities_dom_utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/dom.utilities */ \"./src/utilities/dom.utilities.js\");\n/* harmony import */ var focus_trap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! focus-trap */ \"./node_modules/focus-trap/index.js\");\n/* harmony import */ var focus_trap__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(focus_trap__WEBPACK_IMPORTED_MODULE_1__);\n\n\nvar attributes = {\n  ariaExpanded: \"aria-expanded\",\n  tabIndex: \"tabindex\"\n};\nvar icons = {\n  open: \"fa-bars\",\n  close: \"fa-times\"\n};\nvar ids = {\n  siteNav: \"bc_site-nav\",\n  siteNavToggleButton: \"bc_site-nav__toggle-button\",\n  page: \"bc_page\"\n};\nvar cssClasses = {\n  hidden: \"invisible\",\n  hiddenInit: \"hidden-init\",\n  isActive: \"is-active\",\n  isDisabled: \"is-disabled\",\n  siteNavToggleButtonText: \"bc_site-nav__toggle-button__text\",\n  siteNavListContainer: \"bc_site-nav__list-container\"\n};\nvar invisibleTabIndex = \"-1\";\n/** Allows us to hide an item from tabbing */\n\nvar siteNavFocusTrap;\n/**\n * * Hide/Show the site navigation based on the given shouldShow param\n * @param {boolean} shouldShow if set to true the site navigation will be shown\n */\n\nvar toggleSiteNav = function toggleSiteNav(shouldShow) {\n  var classListAction = shouldShow ? \"add\" : \"remove\";\n  var siteNavToggleButtonElm = document.getElementById(ids.siteNavToggleButton);\n  var buttonIconElm = Object(_utilities_dom_utilities__WEBPACK_IMPORTED_MODULE_0__[\"GetFirstElementOrDefault\"])(siteNavToggleButtonElm, \"i\");\n  var buttonIconTextElm = Object(_utilities_dom_utilities__WEBPACK_IMPORTED_MODULE_0__[\"GetFirstElementOrDefault\"])(siteNavToggleButtonElm, \".\".concat(cssClasses.siteNavToggleButtonText));\n  var siteNavContainerElm = Object(_utilities_dom_utilities__WEBPACK_IMPORTED_MODULE_0__[\"GetFirstElementOrDefault\"])(document.getElementById(ids.siteNav), \".\".concat(cssClasses.siteNavListContainer));\n  var pageElm = document.getElementById(ids.page); // Update toggle button text\n\n  buttonIconTextElm.textContent = shouldShow ? \"Close\" : \"Menu\"; // Toggle the content hidden class\n\n  siteNavContainerElm.classList[shouldShow ? \"remove\" : \"add\"](cssClasses.hidden); // Toggle the toggle button icon\n\n  buttonIconElm.classList.remove(shouldShow ? icons.open : icons.close);\n  buttonIconElm.classList.add(shouldShow ? icons.close : icons.open); // Set / Remove aria-expanded attributes\n\n  Object(_utilities_dom_utilities__WEBPACK_IMPORTED_MODULE_0__[\"SetAttributeForElms\"])([siteNavToggleButtonElm, pageElm], attributes.ariaExpanded, shouldShow); // Set / Remove tab-index inside Site Nav\n\n  updateSiteNavTabIndex(shouldShow); // Activate or deactivate proper focus state\n\n  siteNavFocusTrap[shouldShow ? \"activate\" : \"deactivate\"](); // Add / Remove esc listener\n\n  document[shouldShow ? \"addEventListener\" : \"removeEventListener\"](\"keydown\", handleDocumentKeyDown, true); // Hide / Show the site nav\n\n  document.getElementById(ids.siteNav).classList[classListAction](cssClasses.isActive); // Enable / Disabled page and body\n\n  var disabledElms = [pageElm, document.body];\n\n  if (shouldShow) {\n    Object(_utilities_dom_utilities__WEBPACK_IMPORTED_MODULE_0__[\"AddClassToElms\"])(disabledElms, cssClasses.isDisabled);\n  } else {\n    Object(_utilities_dom_utilities__WEBPACK_IMPORTED_MODULE_0__[\"RemoveClassFromElms\"])(disabledElms, cssClasses.isDisabled);\n  }\n};\n/**\n * Handle any click on the document. An if else block will handle any specific\n * click events we want to capture.\n * @param {document:click} clickEvent - the observable click event\n * @listens document:click\n */\n\n\nvar handleDocumentClick = function handleDocumentClick(clickEvent) {\n  var target = clickEvent.target;\n  var isSiteNavButtonClick = target.id === ids.siteNavToggleButton || target.closest(\"#\".concat(ids.siteNavToggleButton));\n  var pageElm = target.closest(\"#\".concat(ids.page));\n  var isDisabledPageClick = pageElm && pageElm.classList.contains(cssClasses.isDisabled);\n\n  if (isSiteNavButtonClick) {\n    handleSiteNavigationButtonClick(clickEvent);\n  } else if (isDisabledPageClick) {\n    // Close the site nav\n    toggleSiteNav(false);\n  }\n\n  return;\n};\n/**\n * Handle any keydown on the document. An switch statement will handle any specific\n * click events we want to capture.\n * @param {document:keydown} keyDownEvent - the observable keydown event\n * @listens document:keydown\n */\n\n\nvar handleDocumentKeyDown = function handleDocumentKeyDown(keyDownEvent) {\n  switch (event.key) {\n    case \"Escape\":\n      // Close the site nav\n      toggleSiteNav(false);\n      break;\n\n    default:\n      return;\n    // Quit when this doesn't handle the key event.\n  } // Cancel the default action to avoid it being handled twice\n\n\n  event.preventDefault();\n};\n/**\n * Handle the site navigation button click. Works as a toggle button to show / hide site navigation.\n * @param {button:click} clickEvent - the observable click event\n * @listens button:click\n */\n\n\nvar handleSiteNavigationButtonClick = function handleSiteNavigationButtonClick(clickEvent) {\n  var target = clickEvent.target;\n  var siteNavToggleButton = target.id === ids.siteNavToggleButton ? target : target.closest(\"#\".concat(ids.siteNavToggleButton));\n  var buttonAriaExpandedValue = siteNavToggleButton.getAttribute(attributes.ariaExpanded);\n  /** If no aria attribute exists this means the menu is closed and we want to show it. */\n\n  var shouldShowNav = !buttonAriaExpandedValue || !(buttonAriaExpandedValue.toLowerCase() === \"true\");\n  toggleSiteNav(shouldShowNav);\n};\n/**\n * Do stuff after the dom has loaded\n */\n\n\nvar onDocumentReady = function onDocumentReady() {\n  // Allows users to use the menu even if javascript is not enabled\n  document.getElementById(ids.siteNavToggleButton).classList.remove(cssClasses.hiddenInit); //TODO: do we still need this?\n\n  var siteNav = document.getElementById(ids.siteNav);\n  Object(_utilities_dom_utilities__WEBPACK_IMPORTED_MODULE_0__[\"GetFirstElementOrDefault\"])(siteNav, \".\".concat(cssClasses.siteNavListContainer)).classList.add(cssClasses.hidden);\n  Object(_utilities_dom_utilities__WEBPACK_IMPORTED_MODULE_0__[\"SetAttributeForElms\"])(siteNav.querySelectorAll(\"a\"), attributes.tabIndex, invisibleTabIndex);\n  /**\n   * Initialize a focus trap for use when the site navigation is active / visible\n   * See http://davidtheclark.github.io/focus-trap/ for more details.\n   */\n\n  siteNavFocusTrap = focus_trap__WEBPACK_IMPORTED_MODULE_1___default()(document.getElementById(ids.siteNav), {\n    clickOutsideDeactivates: true\n  });\n};\n/**\n * Remove site nav items from the tab index if the site nav is hidden\n * @param {boolean} shouldShow flag that denotes if the site nav should be shown\n */\n\n\nvar updateSiteNavTabIndex = function updateSiteNavTabIndex(shouldShow) {\n  var siteNavLinkElms = document.getElementById(ids.siteNav).querySelectorAll(\"a\");\n  siteNavLinkElms.forEach(function (siteNavLinkElm) {\n    if (shouldShow) {\n      siteNavLinkElm.removeAttribute(attributes.tabIndex);\n    } else {\n      siteNavLinkElm.setAttribute(attributes.tabIndex, invisibleTabIndex);\n    }\n  });\n};\n/** Handler when the DOM is fully loaded */\n\n\ndocument.addEventListener(\"DOMContentLoaded\", onDocumentReady);\n/**\n * Ensure we capture all events\n * https://gomakethings.com/listening-for-click-events-with-vanilla-javascript/\n */\n\ndocument.addEventListener(\"click\", handleDocumentClick, false);\n\n//# sourceURL=webpack://Bc%5Bname%5D/./src/site/SiteNavigation.js?");
=======
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utilities_dom_utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/dom.utilities */ \"./src/utilities/dom.utilities.js\");\n/* harmony import */ var focus_trap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! focus-trap */ \"./node_modules/focus-trap/index.js\");\n/* harmony import */ var focus_trap__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(focus_trap__WEBPACK_IMPORTED_MODULE_1__);\n\n\nvar attributes = {\n  ariaExpanded: \"aria-expanded\",\n  tabIndex: \"tabindex\"\n};\nvar icons = {\n  open: \"fa-bars\",\n  close: \"fa-times\"\n};\nvar ids = {\n  siteNav: \"bc_site-nav\",\n  siteNavToggleButton: \"bc_site-nav__toggle-button\",\n  page: \"bc_page\"\n};\nvar cssClasses = {\n  hidden: \"invisible\",\n  hiddenInit: \"hidden-init\",\n  isActive: \"is-active\",\n  isDisabled: \"is-disabled\",\n  siteNavToggleButtonText: \"bc_site-nav__toggle-button__text\",\n  siteNavListContainer: \"bc_site-nav__list-container\"\n};\nvar invisibleTabIndex = \"-1\";\n/** Allows us to hide an item from tabbing */\n\nvar siteNavFocusTrap;\n/**\r\n * * Hide/Show the site navigation based on the given shouldShow param\r\n * @param {boolean} shouldShow if set to true the site navigation will be shown\r\n */\n\nvar toggleSiteNav = function toggleSiteNav(shouldShow) {\n  var classListAction = shouldShow ? \"add\" : \"remove\";\n  var siteNavToggleButtonElm = document.getElementById(ids.siteNavToggleButton);\n  var buttonIconElm = Object(_utilities_dom_utilities__WEBPACK_IMPORTED_MODULE_0__[\"GetFirstElementOrDefault\"])(siteNavToggleButtonElm, \"i\");\n  var buttonIconTextElm = Object(_utilities_dom_utilities__WEBPACK_IMPORTED_MODULE_0__[\"GetFirstElementOrDefault\"])(siteNavToggleButtonElm, \".\".concat(cssClasses.siteNavToggleButtonText));\n  var siteNavContainerElm = Object(_utilities_dom_utilities__WEBPACK_IMPORTED_MODULE_0__[\"GetFirstElementOrDefault\"])(document.getElementById(ids.siteNav), \".\".concat(cssClasses.siteNavListContainer));\n  var pageElm = document.getElementById(ids.page); // Update toggle button text\n\n  buttonIconTextElm.textContent = shouldShow ? \"Close\" : \"Menu\"; // Toggle the content hidden class\n\n  siteNavContainerElm.classList[shouldShow ? \"remove\" : \"add\"](cssClasses.hidden); // Toggle the toggle button icon\n\n  buttonIconElm.classList.remove(shouldShow ? icons.open : icons.close);\n  buttonIconElm.classList.add(shouldShow ? icons.close : icons.open); // Set / Remove aria-expanded attributes\n\n  Object(_utilities_dom_utilities__WEBPACK_IMPORTED_MODULE_0__[\"SetAttributeForElms\"])([siteNavToggleButtonElm, pageElm], attributes.ariaExpanded, shouldShow); // Set / Remove tab-index inside Site Nav\n\n  updateSiteNavTabIndex(shouldShow); // Activate or deactivate proper focus state\n\n  siteNavFocusTrap[shouldShow ? \"activate\" : \"deactivate\"](); // Add / Remove esc listener\n\n  document[shouldShow ? \"addEventListener\" : \"removeEventListener\"](\"keydown\", handleDocumentKeyDown, true); // Hide / Show the site nav\n\n  document.getElementById(ids.siteNav).classList[classListAction](cssClasses.isActive); // Enable / Disabled page and body\n\n  var disabledElms = [pageElm, document.body];\n\n  if (shouldShow) {\n    Object(_utilities_dom_utilities__WEBPACK_IMPORTED_MODULE_0__[\"AddClassToElms\"])(disabledElms, cssClasses.isDisabled);\n  } else {\n    Object(_utilities_dom_utilities__WEBPACK_IMPORTED_MODULE_0__[\"RemoveClassFromElms\"])(disabledElms, cssClasses.isDisabled);\n  }\n};\n/**\r\n * Handle any click on the document. An if else block will handle any specific\r\n * click events we want to capture.\r\n * @param {document:click} clickEvent - the observable click event\r\n * @listens document:click\r\n */\n\n\nvar handleDocumentClick = function handleDocumentClick(clickEvent) {\n  var target = clickEvent.target;\n  var isSiteNavButtonClick = target.id === ids.siteNavToggleButton || target.closest(\"#\".concat(ids.siteNavToggleButton));\n  var pageElm = target.closest(\"#\".concat(ids.page));\n  var isDisabledPageClick = pageElm && pageElm.classList.contains(cssClasses.isDisabled);\n\n  if (isSiteNavButtonClick) {\n    handleSiteNavigationButtonClick(clickEvent);\n  } else if (isDisabledPageClick) {\n    // Close the site nav\n    toggleSiteNav(false);\n  }\n\n  return;\n};\n/**\r\n * Handle any keydown on the document. An switch statement will handle any specific\r\n * click events we want to capture.\r\n * @param {document:keydown} keyDownEvent - the observable keydown event\r\n * @listens document:keydown\r\n */\n\n\nvar handleDocumentKeyDown = function handleDocumentKeyDown(event) {\n  var key = event.key,\n      keyCode = event.keyCode;\n  /** Ensure ESC key collapses the menu in all browsers */\n\n  if (key === \"Escape\" || keyCode === 27) {\n    toggleSiteNav(false);\n  } else {\n    return;\n  } // Cancel the default action to avoid it being handled twice\n\n\n  event.preventDefault();\n};\n/**\r\n * Handle the site navigation button click. Works as a toggle button to show / hide site navigation.\r\n * @param {button:click} clickEvent - the observable click event\r\n * @listens button:click\r\n */\n\n\nvar handleSiteNavigationButtonClick = function handleSiteNavigationButtonClick(clickEvent) {\n  var target = clickEvent.target;\n  var siteNavToggleButton = target.id === ids.siteNavToggleButton ? target : target.closest(\"#\".concat(ids.siteNavToggleButton));\n  var buttonAriaExpandedValue = siteNavToggleButton.getAttribute(attributes.ariaExpanded);\n  /** If no aria attribute exists this means the menu is closed and we want to show it. */\n\n  var shouldShowNav = !buttonAriaExpandedValue || !(buttonAriaExpandedValue.toLowerCase() === \"true\");\n  toggleSiteNav(shouldShowNav);\n};\n/**\r\n * Do stuff after the dom has loaded\r\n */\n\n\nvar onDocumentReady = function onDocumentReady() {\n  // Allows users to use the menu even if javascript is not enabled\n  document.getElementById(ids.siteNavToggleButton).classList.remove(cssClasses.hiddenInit); //TODO: do we still need this?\n\n  var siteNav = document.getElementById(ids.siteNav);\n  Object(_utilities_dom_utilities__WEBPACK_IMPORTED_MODULE_0__[\"GetFirstElementOrDefault\"])(siteNav, \".\".concat(cssClasses.siteNavListContainer)).classList.add(cssClasses.hidden);\n  Object(_utilities_dom_utilities__WEBPACK_IMPORTED_MODULE_0__[\"SetAttributeForElms\"])(siteNav.querySelectorAll(\"a\"), attributes.tabIndex, invisibleTabIndex);\n  /**\r\n   * Initialize a focus trap for use when the site navigation is active / visible\r\n   * See http://davidtheclark.github.io/focus-trap/ for more details.\r\n   */\n\n  siteNavFocusTrap = focus_trap__WEBPACK_IMPORTED_MODULE_1___default()(document.getElementById(ids.siteNav), {\n    clickOutsideDeactivates: true\n  });\n};\n/**\r\n * Remove site nav items from the tab index if the site nav is hidden\r\n * @param {boolean} shouldShow flag that denotes if the site nav should be shown\r\n */\n\n\nvar updateSiteNavTabIndex = function updateSiteNavTabIndex(shouldShow) {\n  var siteNavLinkElms = document.getElementById(ids.siteNav).querySelectorAll(\"a\");\n  siteNavLinkElms.forEach(function (siteNavLinkElm) {\n    if (shouldShow) {\n      siteNavLinkElm.removeAttribute(attributes.tabIndex);\n    } else {\n      siteNavLinkElm.setAttribute(attributes.tabIndex, invisibleTabIndex);\n    }\n  });\n};\n/** Handler when the DOM is fully loaded */\n\n\ndocument.addEventListener(\"DOMContentLoaded\", onDocumentReady);\n/**\r\n * Ensure we capture all events\r\n * https://gomakethings.com/listening-for-click-events-with-vanilla-javascript/\r\n */\n\ndocument.addEventListener(\"click\", handleDocumentClick, false);\n\n//# sourceURL=webpack://Bc%5Bname%5D/./src/site/SiteNavigation.js?");
>>>>>>> integration

/***/ }),

/***/ "./src/utilities/dom.utilities.js":
/*!****************************************!*\
  !*** ./src/utilities/dom.utilities.js ***!
  \****************************************/
/*! exports provided: AddClassToElms, GetFirstElementOrDefault, RemoveClassFromElms, SetAttributeForElms, ToggleClassForElms */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AddClassToElms\", function() { return AddClassToElms; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetFirstElementOrDefault\", function() { return GetFirstElementOrDefault; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RemoveClassFromElms\", function() { return RemoveClassFromElms; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SetAttributeForElms\", function() { return SetAttributeForElms; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ToggleClassForElms\", function() { return ToggleClassForElms; });\n/**\n * Get the first element based on a css selector\n * @param {*} elm\n * @param {string} querySelector\n * @returns HTMLElement or null if the query selector does not match any elements.\n */\nvar GetFirstElementOrDefault = function GetFirstElementOrDefault(elm, querySelector) {\n  var elms = elm.querySelectorAll(querySelector);\n  return elms ? elms[0] : null;\n};\n/**\n * Set a specific attribute on a group of elements\n * @param {NodeList} elms collection of nodes, usually from document.querySelectorAll\n * @param {string} attributeName name of the attribute\n * @param {*} attributeValue attribute value\n */\n\n\nvar SetAttributeForElms = function SetAttributeForElms(elms, attributeName, attributeValue) {\n  elms.forEach(function (elm) {\n    elm.setAttribute(attributeName, attributeValue);\n  });\n};\n/**\n * Add Css Classes for a group of elements\n * @param {NodeList} elms collection of nodes, usually from document.querySelectorAll\n * @param {string} cssClass space separated string of css classes\n */\n\n\nvar AddClassToElms = function AddClassToElms(elms, cssClass) {\n  elms.forEach(function (elm) {\n    elm.classList.add(cssClass);\n  });\n};\n/**\n * Remove Css Classes for a group of elements\n * @param {NodeList} elms collection of nodes, usually from document.querySelectorAll\n * @param {string} cssClass space separated string of css classes\n */\n\n\nvar RemoveClassFromElms = function RemoveClassFromElms(elms, cssClass) {\n  elms.forEach(function (elm) {\n    elm.classList.remove(cssClass);\n  });\n};\n/**\n * Toggle Css Classes for a group of elements\n * @param {NodeList} elms collection of nodes, usually from document.querySelectorAll\n * @param {string} cssClass space separated string of css classes\n */\n\n\nvar ToggleClassForElms = function ToggleClassForElms(elms, cssClass) {\n  elms.forEach(function (elm) {\n    elm.classList.toggle(cssClass);\n  });\n};\n\n\n\n//# sourceURL=webpack://Bc%5Bname%5D/./src/utilities/dom.utilities.js?");

/***/ })

/******/ });